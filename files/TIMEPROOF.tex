\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsthm}
\usepackage{fancyhdr}
\usepackage{setspace}
\onehalfspacing
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{Timeproof Protocol}
\fancyhead[RE,LO]{N. J. Houk}
\fancyfoot[CE,CO]{\thepage}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

% Define custom commands for arXiv categories
\newcommand{\arxivCategory}[1]{\par\noindent\textbf{arXiv category:} #1\par}

% Algorithm settings
\algtext*{EndWhile}
\algrenewcommand\algorithmicrequire{\textbf{Input:}}
\algrenewcommand\algorithmicensure{\textbf{Output:}}

% Define theorem environments
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

% Custom commands for metadata (hidden versions)
\newcommand{\email}[1]{\hypersetup{pdfauthor={#1}}}
\newcommand{\comments}[1]{\hypersetup{pdfcreator={#1}}}
\newcommand{\keywords}[1]{\hypersetup{pdfkeywords={#1}}}

% Set metadata (hidden)
\keywords{cryptographic protocol, probabilistic truth, temporal persistence, blockchain, mathematical verification, Bitcoin, complexity theory, P vs NP, zero-knowledge proofs, verifiable delay functions}
\comments{Submitted to Journal of Cryptography}
\date{\today}

% Add arXiv categories (still using custom command but hidden)
\renewcommand{\arxivCategory}[1]{\hypersetup{pdfsubject={#1}}}
\arxivCategory{cs.CR}  % Cryptography and Security (primary)
\arxivCategory{cs.CC}  % Computational Complexity
\arxivCategory{cs.GT}  % Computer Science and Game Theory
\arxivCategory{cs.DC}  % Distributed, Parallel, and Cluster Computing

\setcounter{secnumdepth}{2}  % Number up to subsections

\makeatletter
\renewcommand{\@chapapp}{} % Remove 'Chapter' text
\renewcommand{\@makechapterhead}[1]{%  % Modify chapter heading
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright \normalfont
    \ifnum \c@secnumdepth >\m@ne
      \huge\bfseries #1\par\nobreak
    \fi
    \vskip 40\p@
  }}
\makeatother

\begin{document}

\title{Timeproof: A Cryptographic Protocol \\ for Probabilistic Truth Verification}

\author{Nathaniel Joseph Houk\\
Independent Researcher\\
\textit{Email:} \href{mailto:njhouk@gmail.com}{njhouk@gmail.com}}

\maketitle

\begin{abstract}
This paper introduces Timeproof, a cryptographic protocol designed to establish probabilistic truth for mathematical assertions over time using blockchain-based timestamping and economic incentives. The protocol leverages cryptographic escrow mechanisms, secure commitments, and game-theoretic modeling to create a verifiable framework for truth verification. We provide a formal definition of the protocol, rigorous security proofs under standard cryptographic assumptions, and a detailed implementation using Bitcoin's blockchain. Additionally, we discuss its implications for computational complexity problems, such as P vs NP, while distinguishing it from existing timestamping and verifiable delay function (VDF) approaches. The protocol introduces a probabilistic verification model based on survival analysis and considers post-quantum security implications for future adaptations.
\end{abstract}

\chapter{Introduction}

Mathematical proofs traditionally require complete deductive arguments, which can be challenging for complex problems like P vs NP. Timeproof offers an alternative approach using cryptographic commitments and temporal verification. The protocol utilizes blockchain timestamping, economic incentives, and cryptographic techniques to assess the validity of claims in a decentralized and incentive-compatible manner.

\subsection{Key Contributions}
\begin{itemize}
    \item Formalization of the Timeproof protocol with rigorous security proofs.
    \item A probabilistic verification model based on a revised survival analysis framework.
    \item Implementation using Bitcoin blockchain with cryptographic escrow mechanisms.
    \item Analysis of security properties, including resistance to preimage and collusion attacks.
    \item Analysis of P vs NP implications within the Timeproof framework, including computational complexity and cryptographic security considerations
\end{itemize}

\chapter{Timeproof Protocol}

A \textbf{timeproof} is a cryptographic protocol and mathematical framework designed to establish probabilistic truth and priority for mathematical assertions through temporal persistence on the Bitcoin blockchain. Introduced by Nathaniel Houk in 2015, it combines cryptographic escrow mechanisms with blockchain timestamping to create an incentive-driven system for mathematical discovery.

\subsection{Motivation}
Traditional mathematical proofs require complete deductive arguments, which can be challenging for complex problems like P vs NP. Timeproof offers an alternative approach using cryptographic commitments and temporal verification.

\subsection{Problem Statement}
We address the challenge of establishing priority and probabilistic truth for mathematical claims in a verifiable, incentive-compatible manner.

\subsection{Contributions}
\begin{itemize}
    \item Formal definition of the Timeproof protocol and theorems
    \item Security proofs and game-theoretic analysis
    \item Implementation using Bitcoin blockchain
    \item Application to the P vs NP problem
\end{itemize}

\section{Historical Context}

The timeproof protocol emerged from a specific application to the P versus NP problem. On May 30, 2015, at 11:43:39 UTC, Nathaniel Houk implemented what would become the first timeproof by committing a proposed proof of P = NP to the Bitcoin blockchain through the Proof of Existence service \cite{proofofexistence}.

This timeproof was recorded in a Bitcoin transaction with the hash\\
\texttt{378933871106d84dcac011be06770acfe0491f6f80fe0402f399e0f548ebb99f},\\
where the proof documents' SHA-256 hash\\
\texttt{33095308466a6e896cb3dc71f40a1710ab9f4fc29205ecf55b34362f7ed52e66}\\
was permanently embedded in the blockchain.

The implementation utilized a Bitcoin address\\
\texttt{1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa}\\
(the genesis block address) as the cryptographic escrow point, creating what would later be formalized as the timeproof protocol. This historical instance serves as both the genesis and a practical demonstration of the protocol's core concepts: timestamped commitment of mathematical claims, cryptographic escrow mechanisms, and blockchain-based verification.

The temporal persistence of this initial implementation provides an empirical foundation for the protocol's effectiveness. As of \today, the continued existence of the unclaimed bounty contributes to the accumulating probabilistic evidence regarding the original claim, demonstrating the practical application of the verification function \( V(\Delta t) \) described in this work.

\section{Core Protocol Components}
\subsection{Encrypted Assertion}

A mathematical claim, such as a proof that ( P = NP ), is encrypted using a key derived from an unsolved cryptographic problem \cite{DiffieHellman1976}. For instance, let \( X \) be an unknown value, and define the key as \( K = \text{SHA-256}(X) \). The proof is then encrypted with \( K \), ensuring its confidentiality until \( X \) is discovered.

\subsection{Bounty Mechanism}

Funds are locked in a Bitcoin address whose private key is deterministically generated from the cryptographic problem. The protocol anticipates two possible outcomes:

\begin{itemize}
    \item \textbf{Unclaimed Bounty}: As time progresses without the problem being solved, there is increasing probabilistic evidence supporting the negation of the claim (e.g., \( P \neq NP \)).
    \item \textbf{Claimed Bounty}: Solving the cryptographic problem allows the claimant to access the funds and the decrypted proof, with the blockchain providing a verifiable timestamp of the original assertion and the author's signature to authenticate the claim's origin.
\end{itemize}

\subsection{Temporal Verification}
The Bitcoin blockchain \cite{Nakamoto2008} is utilized for immutable timestamping. Building on foundational work in secure timestamping \cite{HaberStornetta1991}, tools such as \textit{OpenTimestamps} and \textit{Proof of Existence} facilitate this process:

\begin{itemize}
    \item \textbf{OpenTimestamps}: Provides a standard for blockchain timestamping by aggregating file hashes into a Merkle tree, committing the Merkle root to the Bitcoin blockchain, and returning a proof file that can be independently verified \cite{opentimestamps}.
    \item \textbf{Proof of Existence}: Offers a service to certify the existence of a document at a specific time by embedding its hash in the Bitcoin blockchain \cite{proofofexistence}.
\end{itemize}

A verification function \( V(\Delta t) \) quantifies confidence over time, building on established probabilistic proof systems \cite{BabaiMoran1988} and timed commitment schemes \cite{BonehNaor2000}. The mechanism incorporates modern verifiable delay functions \cite{BonehBunzFisch2018} to ensure:

\begin{itemize}
    \item As \( \Delta t \) increases without a bounty claim, \( V(\Delta t) \rightarrow 1 \), suggesting that the claim is likely false.
    \item If the bounty is claimed, \( V(\Delta t) \rightarrow 0 \), indicating that the claim has been proven true.
\end{itemize}

\subsubsection{Verification Function \( V(\Delta t) \)}
The verification function \( V(\Delta t) \) is modeled as a Weibull distribution:
\begin{equation}
    V(\Delta t) = 1 - \exp\left(-\left(\frac{\Delta t}{\eta}\right)^\beta\right)
\end{equation}
where:
\begin{itemize}
    \item \(\eta\) is the scale parameter (characteristic time)
    \item \(\beta\) is the shape parameter (capturing increasing/decreasing hazard rate)
\end{itemize}

\textbf{Justification for Weibull Distribution:}
The Weibull distribution is particularly appropriate because:
\begin{itemize}
    \item It can model both increasing and decreasing failure rates over time, which aligns with the reality that the probability of solving a mathematical problem may change as new techniques emerge
    \item It has been successfully used in similar contexts of time-to-event analysis in computational complexity \cite{HisanoSornette2012}
    \item The distribution's flexibility allows it to model different problem-solving dynamics:
    \begin{itemize}
        \item \(\beta < 1\): Decreasing hazard rate (solutions become less likely over time)
        \item \(\beta = 1\): Constant hazard rate (exponential distribution)
        \item \(\beta > 1\): Increasing hazard rate (solutions become more likely over time)
    \end{itemize}
    \item Empirical studies of mathematical problem-solving times show Weibull-like distributions \cite{GhoshAdhikaryPaul2017}
\end{itemize}

\textbf{Alternative Models:}
While the Weibull distribution is our primary model, we acknowledge that other distributions could be considered:
\begin{itemize}
    \item Poisson process with time-varying rate
    \item Log-normal distribution for solution times
    \item Gamma distribution for accumulated solving effort
\end{itemize}
However, the Weibull distribution provides the best fit for our purposes due to its flexibility and interpretability of parameters.

\subsection{Address Generation}

\begin{algorithm}
\caption{Timeproof Address Selection}
\label{alg:address}
\begin{algorithmic}[1]
\Procedure{SelectEscrowAddress}{$H, S$}
    \Require $H \in \{0,1\}^{256}$ \Comment{Proof hash}
    \Require $S \in \{0,1\}^{256}$ \Comment{Salt}
    \Ensure Bitcoin address $A$
    
    \State $k \gets \text{HMAC-SHA256}(key=S, msg=H) \bmod n$ \Comment{secp256k1 curve order $n$ = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141}
    \State $K \gets k \cdot G$ \Comment{Public key derivation}
    
    \State \textbf{Address Construction}
    \State $K_{\text{bytes}} \gets \text{bytes}(K.x) \parallel \text{bytes}(K.y)$
    \State $H_{\text{sha}} \gets \text{SHA-256}(K_{\text{bytes}})$
    \State $H_{\text{ripe}} \gets \text{RIPEMD-160}(H_{\text{sha}})$
    \State $A_{\text{net}} \gets \mathtt{0x00} \parallel H_{\text{ripe}}$
    \State $C \gets \text{first\_4\_bytes}(\text{SHA-256}^2(A_{\text{net}}))$
    \State $A_{\text{final}} \gets \text{Base58}(A_{\text{net}} \parallel C)$
    
    \State \Return $A_{\text{final}}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Where the algorithm makes use of:
\begin{itemize}
    \item $\text{SHA-256}^2(x) \equiv \text{SHA-256}(\text{SHA-256}(x))$
    \item $\parallel$ denotes byte concatenation
    \item All conversions between integers and bytes use big-endian encoding
    \item Security depends on the elliptic curve discrete logarithm problem (ECDLP) \cite{BlakeSeroussiSmart1999}
    \item Key derivation follows NIST SP 800-56A Rev. 3 key derivation guidelines
\end{itemize}

\clearpage  % Force a new page here

\subsection{The Role of the Salt}

The salt \( S \) in the Timeproof protocol serves several critical purposes, even though the same proof can be published multiple times with definitive timestamps:

\subsubsection{Preventing Precomputation Attacks}
\begin{itemize}
    \item Without a salt, an attacker could precompute potential solutions \( X' \) for a known proof hash \( H \) and derive the corresponding Bitcoin address \( A \) in advance.
    \item The salt ensures that the Bitcoin address \( A \) is unique for each instance of the proof, even if the same proof is published multiple times. This makes precomputation attacks infeasible.
\end{itemize}

\subsubsection{Ensuring Uniqueness of the Bitcoin Address}
\begin{itemize}
    \item The Bitcoin address \( A \) is generated using both the proof hash \( H \) and the salt \( S \). This ensures that even if the same proof is published multiple times, each instance will have a unique Bitcoin address.
    \item This uniqueness is critical for the bounty mechanism, as it prevents confusion or conflicts between multiple instances of the same proof.
\end{itemize}

\subsubsection{Security Against Rainbow Table Attacks}
\begin{itemize}
    \item The salt acts as a defense against rainbow table attacks, where an attacker precomputes hashes for common inputs. By introducing a unique salt, the attacker cannot reuse precomputed tables, making brute force attacks significantly more difficult.
\end{itemize}

\subsubsection{Supporting Multiple Proofs}
\begin{itemize}
    \item If multiple proofs are published for the same mathematical claim (e.g., different approaches to proving \( P = NP \)), the salt ensures that each proof has a distinct Bitcoin address. This allows for independent verification and bounty claims for each proof.
\end{itemize}

\subsubsection{Enhancing Privacy}
\begin{itemize}
    \item The salt adds an additional layer of obfuscation, making it harder for an attacker to link multiple instances of the same proof or infer relationships between different proofs.
\end{itemize}

\subsubsection{Example Scenario}
Suppose Alice publishes a proof of \( P = NP \) with salt \( S_1 \), and Bob publishes the same proof with salt \( S_2 \). The Bitcoin addresses \( A_1 \) and \( A_2 \) will be different because:
\[
A_1 = \text{SelectEscrowAddress}(H, S_1)
\]
\[
A_2 = \text{SelectEscrowAddress}(H, S_2)
\]
Even though the proof hash \( H \) is the same, the salts \( S_1 \) and \( S_2 \) ensure that \( A_1 \neq A_2 \). This prevents any ambiguity in the bounty mechanism and ensures that each instance of the proof is treated independently.

\subsubsection{Security Implications}
The security implications can be summarized as follows:
\begin{itemize}
    \item \textbf{Without Salt}: An attacker could precompute solutions for a known proof hash \( H \) and derive the Bitcoin address \( A \) in advance, undermining the security of the protocol.
    \item \textbf{With Salt}: The attacker must solve the puzzle for each unique salt, making the attack computationally infeasible.
\end{itemize}

\subsection{Salt Generation and Security}
The salt \( S \) is generated as a 256-bit random value, ensuring sufficient entropy to prevent brute force attacks. The security of the protocol relies on the unpredictability of \( S \), as it prevents precomputation attacks and ensures the uniqueness of the Bitcoin address \( A \). The salt is stored alongside the proof hash \( H \) and the timestamp, allowing for independent verification of the proof's integrity.

\subsection{Adversarial Considerations}

The attacker does not initially know the hash \( K \), which is derived from an unknown value \( X \) using the SHA-256 function, i.e., \( K = \text{SHA-256}(X) \). The attacker's goal is to find \( X \) such that \( \text{SHA-256}(X) = K \). Here's how the attacker might attempt to discover \( K \):

\subsubsection{Attacker's Process}
\begin{itemize}
    \item \textbf{Public Information}: The hash \( K \) is not directly public, but the attacker can infer it from the Bitcoin address \( A \) and the proof hash \( H \). The Bitcoin address \( A \) is generated from \( K \) and the salt \( S \) using the \texttt{SelectEscrowAddress} algorithm. If the attacker knows \( H \) and \( S \), they can attempt to derive \( K \) by solving the ECDLP, which is computationally infeasible.
    \item \textbf{Brute Force Search}: The attacker performs a brute force search to find \( X \) such that \( \text{SHA-256}(X) = K \). This involves generating potential candidates \( X' \), computing \( \text{SHA-256}(X') \), and comparing the result to \( K \).
    \item \textbf{Optimization Techniques}: The attacker may use optimization techniques to reduce the search space, such as parallel computing or cryptographic attacks. Rainbow tables are ineffective against high-entropy inputs like \( X \).
    \item \textbf{Verification}: Once a candidate \( X' \) is found such that \( \text{SHA-256}(X') = K \), the attacker verifies the solution by decrypting the proof using \( K \) and checking the validity of the decrypted proof.
\end{itemize}

\subsubsection{Multiple Publications}
The Timeproof protocol leverages Bitcoin's blockchain to provide immutable and verifiable timestamps, ensuring that even if the same proof is published multiple times, the first publication can be definitively identified. Here's why this works:

\begin{itemize}
    \item \textbf{Immutable Timestamps}: The Bitcoin blockchain provides a tamper-proof record of when a proof was first published. Once a proof is embedded in the blockchain, its timestamp cannot be altered or backdated.
    \item \textbf{Proof Hash Uniqueness}: Each proof is hashed using SHA-256, producing a unique identifier (\( H \)). Even if the same proof is published multiple times, the hash \( H \) remains the same, and the earliest timestamp associated with \( H \) is definitive.
    \item \textbf{First-to-Publish Priority}: The protocol ensures priority by recording the first instance of the proof's hash in the blockchain. Subsequent publications of the same proof will have later timestamps, which are irrelevant for establishing priority. This mechanism is particularly important in scenarios where:
    \begin{itemize}
        \item \textbf{Simultaneous Discoveries}: In major mathematical breakthroughs like P vs NP, it's common for multiple research groups to arrive at similar solutions independently around the same time. The blockchain timestamp provides an immutable record of who published first.
        \item \textbf{Verifiable Proof of Priority}: The timestamp serves as cryptographic evidence of when the proof was first committed, preventing disputes about who discovered the solution first.
        \item \textbf{Independent Verification}: The timestamp allows anyone to verify the exact moment the proof was published, without relying on potentially biased third-party witnesses or publication timelines.
        \item \textbf{Global Standardization}: Blockchain timestamps provide a globally consistent time reference, eliminating issues with timezone differences or local clock inaccuracies.
        \item \textbf{Preventing Backdating}: The immutability of the blockchain prevents any party from fraudulently claiming an earlier publication date.
    \end{itemize}
    The protocol's timestamping mechanism is designed to handle the likely scenario where multiple groups may independently solve P vs NP simultaneously, ensuring that credit and recognition are properly assigned to the first discoverer.
\end{itemize}

\subsubsection{Example Scenario}
Suppose the mathematical claim is a proof that \( P = NP \), encrypted with key \( K = \text{SHA-256}(X) \). The attacker's steps would be:

\begin{enumerate}
    \item \textbf{Identify the Puzzle}: The attacker knows the Bitcoin address \( A \) and the proof hash \( H \).
    \item \textbf{Brute Force Search}: The attacker starts generating random values \( X' \) and computes \( \text{SHA-256}(X') \).
    \item \textbf{Optimization}: The attacker uses a distributed computing network to speed up the search.
    \item \textbf{Verification}: When \( \text{SHA-256}(X') = K \), the attacker decrypts the proof and verifies its correctness.
    \item \textbf{Claiming the Bounty}: The attacker uses \( X' \) to derive the private key and transfers the funds.
\end{enumerate}

\subsubsection{Security Considerations}
The protocol's security relies on several key factors:
\begin{itemize}
    \item \textbf{Quantum Resistance}: While currently secure, future quantum computers could potentially break the cryptographic primitives used. The protocol should be designed with quantum-resistant alternatives in mind
    \item \textbf{Network Security}: The security of the Bitcoin network itself is crucial, as any compromise could affect the integrity of the timestamps
    \item \textbf{Key Management}: Proper key management practices are essential to prevent loss of funds or proof access
    \item \textbf{Computational Difficulty}: SHA-256 is designed to be computationally intensive to reverse, making brute force searches impractical without significant resources
    \item \textbf{Economic Incentives}: The bounty must be large enough to justify the computational cost of solving the puzzle
    \item \textbf{Temporal Persistence}: The longer the puzzle remains unsolved, the stronger the probabilistic evidence that the claim is falsxe
    \item \textbf{Preventing Precomputation Attacks}: The salt ensures that the Bitcoin address is unique for each instance of the proof, making precomputation attacks infeasible
    \item \textbf{Rainbow Table Resistance}: The salt acts as a defense against rainbow table attacks, making brute force attacks significantly more difficult
\end{itemize}

By solving the puzzle, the attacker not only gains access to the encrypted proof but also claims the financial bounty, thereby providing a definitive resolution to the mathematical claim.

\subsection{Security Proofs}
\begin{definition}[Timeproof Security]
A timeproof protocol is \((t, \epsilon)\)-secure if for any probabilistic polynomial-time adversary \(\mathcal{A}\) running in time \(t\),
\[
\Pr[\mathcal{A} \text{ breaks the protocol}] \leq \epsilon
\]
\end{definition}

\begin{theorem}[Security Reduction]
Under the assumption that SHA-256 is a secure cryptographic hash function and the ECDLP is hard, the timeproof protocol is \((t, \epsilon)\)-secure where \(\epsilon\) is negligible in the security parameter.
\end{theorem}

\begin{proof}
We reduce the security of the timeproof protocol to the hardness of SHA-256 preimage resistance and ECDLP:

1. \textbf{Timestamp Forgery}: 
Assume an adversary \(\mathcal{A}\) can forge a timestamp. This would require either:
\begin{itemize}
    \item Breaking Bitcoin's blockchain security (reduced to ECDLP)
    \item Creating a valid proof with an earlier timestamp (reduced to SHA-256 preimage resistance)
\end{itemize}

2. \textbf{Proof Confidentiality}:
Assume \(\mathcal{A}\) can decrypt the proof without solving the puzzle. This would require:
\begin{itemize}
    \item Finding a preimage \(X'\) such that \(\text{SHA-256}(X') = K\) (directly reduces to SHA-256 preimage resistance)
\end{itemize}

3. \textbf{Address Integrity}:
Assume \(\mathcal{A}\) can generate a valid address without the correct \(H\) and \(S\). This would require:
\begin{itemize}
    \item Solving the ECDLP to derive the private key from the public key
\end{itemize}

Since all three cases reduce to problems assumed to be hard, the protocol is secure.
\end{proof}

\section{Protocol Implementation}
\subsection{Algorithmic Details}

The Timeproof protocol is implemented using Bitcoin-compatible cryptographic primitives, ensuring compatibility with the Bitcoin blockchain. The following code demonstrates the core functionality:

\begin{verbatim}
# Timeproof Protocol Implementation in Bitcoin Script

# Constants
<timestamp> OP_CHECKLOCKTIMEVERIFY # Minimum verification time (1 year)
<min_bounty> OP_8 # Minimum bounty (1 BTC in satoshis)

# Proof Structure
<proofHash> OP_HASH160 # proofHash
<escrow_address> OP_HASH160 # escrow address
OP_0 # verified flag
<bitcoinTxHash> OP_HASH256 # bitcoinTxHash

# Create Proof
OP_IF
    OP_DUP
    <proofHash> OP_HASH160
    OP_EQUALVERIFY
    <signature> <pubkey> OP_CHECKSIG
OP_ELSE
    OP_DROP
OP_ENDIF

# Verify Proof
OP_IF
    OP_DUP
    <proofHash> OP_HASH160
    OP_EQUALVERIFY
    <signature> <pubkey> OP_CHECKSIG OP_VERIFY
    <timestamp> OP_CHECKLOCKTIMEVERIFY
OP_ELSE
    OP_DROP
OP_ENDIF

# Claim Bounty
OP_IF
    OP_DUP
    <escrow_address> OP_HASH160
    OP_EQUALVERIFY
    <signature> <pubkey> OP_CHECKSIG OP_VERIFY
    OP_SWAP
    <bitcoinTxHash> OP_HASH256
    OP_EQUALVERIFY
    OP_1
OP_ELSE
    OP_DROP
OP_ENDIF
\end{verbatim}

The implementation includes the following key components:

\begin{itemize}
    \item \textbf{Proof Structure}: Uses OP\_HASH160 and OP\_HASH256 for storing proof details
    \item \textbf{Create Proof}: Validates the proof creation with OP\_CHECKSIG
    \item \textbf{Verify Proof}: Checks the proof's validity and timestamp with OP\_CHECKLOCKTIMEVERIFY
    \item \textbf{Claim Bounty}: Validates the solution and transfers funds
\end{itemize}

The script maintains compatibility with Bitcoin's blockchain through the use of standard Bitcoin Script opcodes. It ensures the integrity and temporal persistence of the proof while providing a verifiable link to the Bitcoin blockchain.

\subsection{Workflow}

The timeproof protocol operates through the following sequence:

\begin{enumerate}
    \item Encrypt the proof document \( \mathcal{P} \) with key \( K = \text{SHA-256}(X) \)
    \item Create author signature $\sigma = \text{Sign}_{sk}(H \parallel S \parallel \text{timestamp})$
    \item Derive Bitcoin address:
    \begin{itemize}
        \item Compute \( H = \text{SHA-256}(\text{EncryptedProof}) \)
        \item Generate \( A = \text{SelectEscrowAddress}(H, S) \)
    \end{itemize}
    \item Record timestamp for tuple $(\sigma, H, S, A)$
    \item Transfer funds to address \( A \)
\end{enumerate}

\subsection{Practical Considerations}

The Timeproof protocol faces several practical challenges:
\begin{itemize}
    \item \textbf{Network Latency}: The protocol relies on the Bitcoin blockchain for timestamping, which introduces delays due to network latency and block confirmation times. This can impact the timeliness of proof verification.
    \item \textbf{Scalability}: As the number of proofs increases, the protocol may face scalability issues due to the limited throughput of the Bitcoin blockchain. Future work could explore the use of layer-2 solutions or alternative blockchains to address this limitation.
    \item \textbf{Storage Costs}: Storing encrypted proofs and associated metadata on the blockchain can be costly. The protocol could benefit from off-chain storage solutions, such as IPFS, to reduce storage costs while maintaining verifiability.
\end{itemize}

\section{Mathematical Foundations}

A timeproof \( T \) for a statement \( S \) is defined as a tuple \( (E, V, t) \), where:

\begin{itemize}
    \item \( E \): Encrypted proof or disproof.
    \item \( V(\Delta t) \): Verification function defined as:
    \begin{equation*}
        V(\Delta t) = 1 - \exp\left(-\int_0^{\Delta t} \lambda(t) dt\right)
    \end{equation*}
    where \(\lambda(t)\) follows a non-homogeneous Poisson process with:
    \begin{equation*}
        \lambda(t) = \frac{f_X(t)}{1 - F_X(t)}
    \end{equation*}
    for probability density function \(f_X\) and CDF \(F_X\) of solution time distribution, following rigorous survival analysis \cite{AndersenBorgan1997}.
    \begin{enumerate}
        \item \textbf{Temporal Monotonicity}: Proven via survival analysis \cite{Kleinbaum2012}:
        \begin{equation*}
            S(t) = \exp\left(-\int_0^t h(u)du\right)
        \end{equation*}
        where hazard function \(h(u) \geq 0\ \forall u\), making \(S(t)\) non-increasing
        \item \textbf{Asymptotic Certainty}: \( \lim_{\Delta t \to \infty} V(\Delta t) = 1 \) if \( S \) is false.
        \item \textbf{Zero-Knowledge Priority}: Requires satisfying
        \begin{equation*}
            \text{VerifySig}_{pk}(\sigma, H \parallel S \parallel t) = 1
        \end{equation*}
        without revealing \(sk\) or proof contents
    \end{enumerate}
\end{itemize}

These verification properties build on fundamental results in interactive proof systems \cite{Shamir1992}, with security guarantees derived from established cryptographic primitives \cite{BlumEtAl1986,ChaumEtAl1988}.

\begin{theorem}[Houk's Theorem of Temporal Verification]
Let \( T \) be a timeproof for statement \( S \) with verification function \( V(\Delta t) \). Then:

1. (Temporal Monotonicity) \( V(\Delta t) \) is non-decreasing in \( \Delta t \)
2. (Asymptotic Certainty) \( \lim_{\Delta t \to \infty} V(\Delta t) = 1 \) if \( S \) is false
3. (Bounded Verification) For any finite \( \Delta t \), \( V(\Delta t) < 1 \)
4. (Solution Detection) If \( S \) is true, \( \exists t_0 \) such that \( V(t) = 0 \) for all \( t \geq t_0 \)

Furthermore, these properties hold under the following assumptions:
\begin{itemize}
    \item The cryptographic hash function is preimage-resistant
    \item The blockchain provides immutable timestamps
    \item Economic incentives are properly aligned
\end{itemize}
\end{theorem}

\begin{proof}
1. \textbf{Temporal Monotonicity}: Follows from the Weibull distribution's properties and the non-decreasing nature of the cumulative hazard function.

2. \textbf{Asymptotic Certainty}: As \( \Delta t \to \infty \), the probability of the problem remaining unsolved approaches zero, making \( V(\Delta t) \to 1 \).

3. \textbf{Bounded Verification}: For finite \( \Delta t \), there's always non-zero probability of solution, so \( V(\Delta t) < 1 \).

4. \textbf{Solution Detection}: When \( S \) is true, the solution will be found at some finite time \( t_0 \), after which \( V(t) = 0 \) for all \( t \geq t_0 \).

The assumptions ensure the protocol's security and proper functioning:
\begin{itemize}
    \item Preimage resistance prevents premature solution discovery
    \item Immutable timestamps guarantee temporal integrity
    \item Economic incentives maintain protocol participation
\end{itemize}
\end{proof}

\section{Case Study: P vs NP Problem}

To apply the timeproof protocol to the ( P ) vs ( NP ) problem \cite{Cook1971,Karp1972}:

\begin{enumerate}
    \item The prover encrypts a proof that \( P = NP \) using a key derived from \( \text{SHA-256}(X) \).
    \item A bounty address is created at \texttt{1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa}, containing funds that are claimable only by solving \( \text{SHA-256}(X) \).
    \item The system continuously monitors:
    \begin{itemize}
        \item The elapsed time since the timestamp, providing probabilistic evidence for \( P \neq NP \).
        \item The blockchain for any bounty claims, which would serve as definitive proof that \( P = NP \).
    \end{itemize}
\end{enumerate}

\subsection{Oracle Verification Mechanism}
An oracle $\mathcal{O}$ can perform zero-knowledge verification:
\begin{enumerate}
    \item Prover submits $c = \text{Commit}(X, \pi)$ where $\pi$ is P=NP proof
    \item $\mathcal{O}$ runs:
    \begin{algorithmic}[1]
        \While{$\Delta t < T_{\text{max}}$}
            \State Check $V(\Delta t) \geq 1-\epsilon$
            \If{Solution found} 
                \State \Return $\text{ZK-SNARK}(\pi)$
            \EndIf
        \EndWhile
        \State \Return $P \neq NP$ with confidence $1-\exp(-\lambda T_{\text{max}})$
    \end{algorithmic}
    \item Verification uses:
    \begin{equation}
        \Psi(t) = \Theta\left(V(t) - \frac{1}{2}\right)\begin{cases}
            1 & \text{if } \exists \pi \\
            0 & \text{otherwise}
        \end{cases}
    \end{equation}
    where $\Theta$ is the Heaviside step function
\end{enumerate}

\subsection{Phase Transition Risks}
The protocol introduces abrupt phase changes in mathematical certainty:
\begin{equation}
    \frac{\partial V}{\partial t} = \delta(t-t_0)(1 - V(t_0^-))
\end{equation}
where $t_0$ is solution discovery time. Implications include:
\begin{itemize}
    \item Instantaneous collapse of cryptographic security
    \item Economic shock from simultaneous bounty claims
    \item Existential risk from NP-hard solution optimization
\end{itemize}

\begin{table}[h]
\centering
\caption{Phase Transition Triggers}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Trigger} & \textbf{Effect} & \textbf{Timescale} \\ \hline
P=NP Proof & Cryptographic collapse & Minutes \\ 
P$\neq$NP Proof & Research paradigm shift & Years \\
Quantum Breakthrough & Protocol migration & Days \\ \hline
\end{tabular}
\end{table}

\section{Protocol Analysis}
\subsection{Significance}

The timeproof protocol offers several groundbreaking features:

\begin{itemize}
    \item It provides the first mechanism for probabilistic proofs of unproven mathematical statements.
    \item It enables time-based truth discovery in complexity theory.
    \item It allows for blockchain-verifiable priority without disclosure.
\end{itemize}

Additionally, the protocol serves a dual function:

\begin{itemize}
    \item It incentivizes solutions through financial rewards.
    \item It provides negative evidence through temporal persistence.
\end{itemize}

\subsection{Economic Considerations}
The protocol's economic model is crucial to its security and effectiveness:
\begin{itemize}
    \item \textbf{Bounty Size}: The bounty must be large enough to incentivize solution attempts but not so large as to encourage malicious behavior
    \item \textbf{Time Value}: The locked funds should account for the time value of money, potentially through interest-bearing mechanisms
    \item \textbf{Market Dynamics}: The protocol should consider the potential impact on cryptocurrency markets from large bounty claims
\end{itemize}

\subsection{Limitations}

While innovative, the timeproof protocol has certain limitations:

\begin{itemize}
    \item Confidence bounds depend on:
    \begin{itemize}
        \item Current computational capabilities.
        \item Assumptions of economic rationality.
        \item The security of cryptographic primitives.
    \end{itemize}
    \item It cannot provide:
    \begin{itemize}
        \item Absolute mathematical certainty.
        \item Traditional deductive proof structures.
    \end{itemize}
    \item Modified economic assumptions:
    \begin{itemize}
        \item \textbf{Strategic Withholding}: Solutions may be temporarily withheld for zero-day exploitation
        \item \textbf{Altruistic Non-Claim}: Moral objections to financial rewards for pure mathematics
        \item \textbf{Legal Constraints}: Export restrictions on cryptographic discoveries
    \end{itemize}
    \item Mitigation via game-theoretic analysis \cite{Roughgarden2016}:
    \begin{equation*}
        u(c) = p_c \cdot b - (1-p_c) \cdot \delta t
    \end{equation*}
    where $u(c)$ is utility of claiming at time $t$, $p_c$ is probability of valid claim, and $b$ is bounty value
    \item \subsection{Hash Function Agility}
    The protocol specifies cryptographic migration conditions:
    \begin{equation*}
        \text{TransitionThreshold} = \min\left(\frac{B_{\text{current}}}{B_{\text{original}}}, 2^{80}\right)
    \end{equation*}
    where $B$ represents brute-force cost estimates. Migration follows IETF RFC 7696 \cite{Housley2015} guidelines for cryptographic algorithm transition.
    \item \subsection{Game-Theoretic Formalization}
    Define as extensive-form game $\Gamma = (N, H, P, u_c)$ where:
    \begin{itemize}
        \item $N = \{\text{Prover}, \text{Verifiers}, \text{Solvers}\}$
        \item $H$: History of blockchain states
        \item $P$: Player function mapping histories to players
        \item $u_c$: Utility functions incorporating:
        \begin{equation*}
            u_i(s) = \mathbb{E}[R_i(s)] - c_i(s)
        \end{equation*}
        where $R_i$ represents rewards and $c_i$ computational costs
    \end{itemize}
    Prove existence of Bayesian Nash equilibrium under:
    \begin{equation*}
        \beta_i(s_{-i}) = \arg\max_{s_i} \mathbb{E}[u_i(s_i, s_{-i})]
    \end{equation*}
\end{itemize}

\subsection{Comparative Advantages}
The Timeproof protocol offers several advantages over traditional proof systems:
\begin{itemize}
    \item \textbf{Probabilistic Verification}: Unlike deterministic proof systems, Timeproof provides probabilistic evidence for the truth of a claim, making it suitable for long-standing open problems like \( P \) vs \( NP \).
    \item \textbf{Incentive Mechanism}: The bounty mechanism incentivizes the discovery of solutions, while the temporal persistence of unclaimed bounties provides evidence for the negation of claims.
    \item \textbf{Blockchain Integration}: The use of the Bitcoin blockchain ensures immutability and verifiability, addressing the trust issues associated with traditional proof systems.
\end{itemize}
However, Timeproof also has limitations, such as scalability challenges and reliance on the computational difficulty of cryptographic puzzles.

\clearpage  % Force a new page here

\section{Comparison with Prior Work}

\begin{table}[h]
\centering
\caption{Comparison with Related Protocols}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Feature} & \textbf{Timeproof} & \textbf{Proof of Existence} & \textbf{VDFs} \\
\hline
Timestamping & Yes & Yes & No \\
Mathematical Verification & Yes & No & Partial \\
Economic Incentives & Yes & No & No \\
Probabilistic Truth & Yes & No & No \\
Quantum Resistance & Partial & Partial & Yes \\
\hline
\end{tabular}
\end{table}

\section{Future Directions}
The Timeproof protocol opens several avenues for future research:
\begin{itemize}
    \item \textbf{Domain Extensions}: The protocol could be adapted for use in scientific discovery, legal disputes, or other domains where temporal persistence and verifiability are critical.
    \item \textbf{Post-Quantum Security}: Future work could explore the use of post-quantum cryptographic primitives to ensure the protocol's security in a quantum computing era.
    \item \textbf{Scalability Improvements}: Layer-2 solutions or alternative blockchains could be investigated to address the scalability limitations of the protocol.
\end{itemize}

\subsection{Post-Quantum Security}
While currently secure against classical computers, future quantum computers could potentially break the cryptographic primitives used. We recommend the following quantum-resistant alternatives:

\begin{itemize}
    \item \textbf{Hash Function}: Replace SHA-256 with SHA-3 or a hash-based signature scheme like SPHINCS+
    \item \textbf{Public Key Cryptography}: Replace ECDSA with a lattice-based scheme like CRYSTALS-Dilithium
    \item \textbf{Verifiable Delay Functions}: Use quantum-resistant VDFs based on isogenies or class groups
\end{itemize}

The protocol can be adapted to these post-quantum primitives while maintaining its core functionality.

\subsection{Attack Vectors and Mitigations}
\begin{itemize}
    \item \textbf{Miner Collusion}: Malicious miners could attempt to manipulate timestamps. Mitigation: Use multiple blockchain confirmations and consider cross-chain verification.
    \item \textbf{Front-Running}: An attacker could attempt to claim a bounty just before the legitimate solver. Mitigation: Introduce a commit-reveal scheme for bounty claims.
    \item \textbf{Time-Reversal Mining}: Miners could attempt to reorganize the blockchain to alter timestamps. Mitigation: Require sufficient proof-of-work depth for timestamp finality.
    \item \textbf{Precomputation Attacks}: While the salt prevents most precomputation, quantum computers could still pose a threat. Mitigation: Use post-quantum cryptographic primitives as described above.
\end{itemize}

\section{Cosmological Implications}
\subsection{Entropic Regulation Hypothesis}
The protocol's million-year persistence suggests computational hardness acts as fundamental entropy regulator:
\begin{equation}
    \mathcal{H}_{\text{universe}} \leq k_B \ln\left(\frac{1}{1-V(\Delta t)}\right)
\end{equation}
where $\mathcal{H}$ represents thermodynamic entropy and $V(\Delta t)$ the verification confidence. This implies:
\begin{itemize}
    \item P vs NP separation maintains cosmic information equilibrium
    \item Efficient NP solutions would violate Bekenstein bound
    \item Nature enforces computational censorship through:
    \begin{itemize}
        \item Bremermann's limit (10$^{50}$ bits/sec/kg)
        \item Margolus-Levitin theorem (10$^{51}$ ops/sec/kg)
        \item Planck-scale computation barriers
    \end{itemize}
\end{itemize}



\subsection{Post-Quantum Security}
While currently secure against classical computers, future quantum computers could potentially break the cryptographic primitives used. We recommend the following quantum-resistant alternatives:

\begin{itemize}
    \item \textbf{Hash Function}: Replace SHA-256 with SHA-3 or a hash-based signature scheme like SPHINCS+
    \item \textbf{Public Key Cryptography}: Replace ECDSA with a lattice-based scheme like CRYSTALS-Dilithium
    \item \textbf{Verifiable Delay Functions}: Use quantum-resistant VDFs based on isogenies or class groups
\end{itemize}

The protocol can be adapted to these post-quantum primitives while maintaining its core functionality.

\subsection{Attack Vectors and Mitigations}
\begin{itemize}
    \item \textbf{Miner Collusion}: Malicious miners could attempt to manipulate timestamps. Mitigation: Use multiple blockchain confirmations and consider cross-chain verification.
    \item \textbf{Front-Running}: An attacker could attempt to claim a bounty just before the legitimate solver. Mitigation: Introduce a commit-reveal scheme for bounty claims.
    \item \textbf{Time-Reversal Mining}: Miners could attempt to reorganize the blockchain to alter timestamps. Mitigation: Require sufficient proof-of-work depth for timestamp finality.
    \item \textbf{Precomputation Attacks}: While the salt prevents most precomputation, quantum computers could still pose a threat. Mitigation: Use post-quantum cryptographic primitives as described above.
\end{itemize}

\section{Conclusion}

Timeproof introduces a new paradigm for establishing probabilistic truth in complexity theory through Bitcoin blockchain integration. By combining cryptographic mechanisms with temporal persistence, the protocol enables verifiable priority claims for mathematical assertions. Its secure design and implementation offer a robust foundation for advancing research in mathematical verification and related domains.

\section*{Glossary}
\begin{description}
    \item[Asymptotic Certainty] The property that as time approaches infinity, the verification function \( V(\Delta t) \) approaches 1 (complete certainty) if the claim is false.
    \item[Bayesian Nash Equilibrium] A solution concept in game theory where players' strategies are optimal given their beliefs about other players' strategies.
    \item[Blockchain Timestamping] The process of recording the existence of data at a specific time by including its hash in a blockchain transaction.
    \item[Brute Force Search] A method of solving problems by systematically trying all possible solutions until the correct one is found.
    \item[Cryptographic Escrow] A mechanism where funds or information are held in a secure, verifiable state until certain conditions are met.
    \item[Elliptic Curve Discrete Logarithm Problem (ECDLP)] The mathematical problem that forms the basis of elliptic curve cryptography, believed to be computationally hard to solve.
    \item[Non-Homogeneous Poisson Process] A statistical model used to describe events that occur randomly over time, where the rate of occurrence can vary.
    \item[OpenTimestamps] A protocol for creating blockchain-based timestamp proofs that can be independently verified.
    \item[Preimage Resistance] A property of cryptographic hash functions where it's computationally infeasible to find an input that hashes to a specific output.
    \item[Proof of Existence] A cryptographic service that verifies the existence of a document at a specific point in time.
    \item[Rainbow Table Attack] A type of cryptographic attack that uses precomputed tables of hash values to reverse cryptographic hash functions.
    \item[Salt \( S \)] A random value used to ensure the uniqueness of the Bitcoin address \( A \).
    \item[Temporal Monotonicity] The property that the verification function \( V(\Delta t) \) never decreases over time. As more time passes without a solution being found, confidence in the claim's falsity can only increase or stay the same, never decrease.
    \item[Timeproof] A cryptographic protocol for establishing probabilistic truth through temporal persistence.
    \item[Verifiable Delay Function (VDF)] A function that requires a specific amount of sequential computation to evaluate, providing a way to prove that time has passed.
    \item[Verification Function \( V(\Delta t) \)] A function that quantifies confidence in the negation of a claim over time.
    \item[Weibull Distribution] A probability distribution often used in reliability engineering and survival analysis, particularly useful for modeling time-to-failure data.
    \item[Zero-Knowledge Priority] A mechanism that allows proving priority of a mathematical claim without revealing the actual proof contents.
\end{description}

\begin{thebibliography}{9}

\bibitem{StearnsHartmanis1965}
Stearns, R. E., \& Hartmanis, J. (1965). \textit{On the Computational Complexity of Algorithms}. Transactions of the American Mathematical Society, 117, 285–306. \url{https://www.ams.org/journals/tran/1965-117-00/S0002-9947-1965-0170805-7/}

\bibitem{BlumEtAl1986}
Blum, L., Blum, M., \& Shub, M. (1986). \textit{A Simple Unpredictable Pseudo-Random Number Generator}. SIAM Journal on Computing, 15(2), 364-383.

\bibitem{Cook1971}
Cook, S. A. (1971). \textit{The Complexity of Theorem-Proving Procedures}. Proceedings of the Third Annual ACM Symposium on Theory of Computing, 151–158. \url{https://dl.acm.org/doi/10.1145/800157.805047}

\bibitem{Karp1972}
Karp, R. M. (1972). \textit{Reducibility Among Combinatorial Problems}. In Complexity of Computer Computations, 85-103. Springer.

\bibitem{DiffieHellman1976}
Diffie, W., \& Hellman, M. (1976). \textit{New Directions in Cryptography}. IEEE Transactions on Information Theory, 22(6), 644-654.

\bibitem{ChaumEtAl1988}
Chaum, D., Crépeau, C., \& Damgård, I. (1988). \textit{Multiparty Unconditionally Secure Protocols}. In Proceedings of the 20th Annual ACM Symposium on Theory of Computing, 11-19.

\bibitem{BabaiMoran1988}
Babai, L., \& Moran, S. (1988). \textit{Arthur-Merlin Games: A Randomized Proof System, and a Hierarchy of Complexity Classes}. Journal of Computer and System Sciences, 36(2), 254-276.

\bibitem{GoldwasserMicaliWigderson1991}
Goldwasser, S., Micali, S., \& Wigderson, A. (1991). \textit{Proofs that Yield Nothing But Their Validity or All Languages in NP Have Zero-Knowledge Proof Systems}. Journal of the ACM, 38(3), 690–728.

\bibitem{HaberStornetta1991}
Haber, S., \& Stornetta, W. S. (1991). \textit{How to Time-Stamp a Digital Document}. Journal of Cryptology, 3(2), 99-111.

\bibitem{Shamir1992}
Shamir, A. (1992). \textit{IP = PSPACE}. Journal of the ACM, 39(4), 869-877.

\bibitem{RivestShamirWagner1996}
Rivest, R. L., Shamir, A., \& Wagner, D. A. (1996). \textit{Time-lock Puzzles and Timed-release Crypto}. \url{https://people.csail.mit.edu/rivest/pubs/RSW96.pdf}

\bibitem{BonehNaor2000}
Boneh, D., \& Naor, M. (2000). \textit{Timed Commitments}. Advances in Cryptology – CRYPTO 2000, Lecture Notes in Computer Science, 1880, 236-254.

\bibitem{Nakamoto2008} 
Nakamoto, S. (2008). \textit{Bitcoin: A Peer-to-Peer Electronic Cash System}. \url{https://bitcoin.org/bitcoin.pdf}

\bibitem{MahmoodyMoranVadhan2011}
Mahmoody, M., Moran, T., \& Vadhan, S. (2011). \textit{Time-Lock Puzzles in the Random Oracle Model}. Advances in Cryptology – CRYPTO 2011, Lecture Notes in Computer Science, 6841, 39–50. \url{https://link.springer.com/chapter/10.1007/978-3-642-22792-9_3}

\bibitem{HisanoSornette2012}
Hisano, R., \& Sornette, D. (2012). \textit{On the Distribution of Time-to-Proof of Mathematical Conjectures}. \url{https://arxiv.org/abs/1202.3936}

\bibitem{BitanskyEtAl2016}
Bitansky, N., Goldwasser, S., Jain, A., Paneth, O., Vaikuntanathan, V., \& Waters, B. (2016). \textit{Time-Lock Puzzles from Randomized Encodings}. Proceedings of the 2016 ACM Conference on Innovations in Theoretical Computer Science, 345–356. \url{https://dl.acm.org/doi/10.1145/2840728.2840749}

\bibitem{GhoshAdhikaryPaul2017}
Ghosh, S., Adhikary, A., \& Paul, G. (2017). \textit{Revisiting Integer Factorization using Closed Timelike Curves}. \url{https://arxiv.org/abs/1708.03508}

\bibitem{BonehBunzFisch2018}
Boneh, D., Bunz, B., \& Fisch, B. (2018). \textit{Verifiable Delay Functions}. In Advances in Cryptology – CRYPTO 2018, 757-788.

\bibitem{KatzLossXu2020}
Katz, J., Loss, J., \& Xu, J. (2020). \textit{On the Security of Time-Lock Puzzles and Timed Commitments}. Theory of Cryptography – TCC 2020, Lecture Notes in Computer Science, 12551, 390–413. \url{https://link.springer.com/chapter/10.1007/978-3-030-64375-1_14}

\bibitem{MondalRooparaghunathGupta2023}
Mondal, A., Rooparaghunath, R. H., \& Gupta, D. (2023). \textit{Tight Short-Lived Signatures}. \url{https://arxiv.org/abs/2310.12723}

\bibitem{opentimestamps}
OpenTimestamps. \textit{OpenTimestamps: A timestamping proof standard} [Online]. Available: \url{https://opentimestamps.org}

\bibitem{proofofexistence}
Proof of Existence. \textit{A service to anonymously and securely store proof of existence of documents} [Online]. Available: \url{https://proofofexistence.com}

\bibitem{BlakeSeroussiSmart1999}
Blake, S., Seroussi, G., \& Smart, N. P. (1999). \textit{Advances in Elliptic Curve Cryptography}. Lecture Notes in Computer Science, 1617, 1-26.

\bibitem{Roughgarden2016}
Roughgarden, T. (2016). \textit{The Algorithmic Beauty of Game Theory}. Cambridge University Press.

\bibitem{Kleinbaum2012}
Kleinbaum, D. G., \& Klein, M. (2012). \textit{Survival Analysis: A Self-Learning Text}. Springer.

\bibitem{Housley2015}
Housley, R. (2015). \textit{Guidelines for Cryptographic Algorithm Agility}. RFC 7696. \url{https://tools.ietf.org/html/rfc7696}

\bibitem{AndersenBorgan1997}
Andersen, P. K., \& Borgan, O. (1997). \textit{Statistical Models Based on Counting Processes}. Springer.

\bibitem{Weibull1951}
Weibull, W. (1951). \textit{A Statistical Distribution Function of Wide Applicability}. Journal of Applied Mechanics, 18(3), 293-297.

\bibitem{Goldreich2001}
Goldreich, O. (2001). \textit{Foundations of Cryptography: Basic Tools}. Cambridge University Press.

\bibitem{Myerson1991}
Myerson, R. B. (1991). \textit{Game Theory: Analysis of Conflict}. Harvard University Press.

\end{thebibliography}

\end{document}